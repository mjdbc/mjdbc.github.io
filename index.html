<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset=utf-8>
    <meta http-equiv=X-UA-Compatible content="IE=edge">
    <meta name=viewport content="width=device-width,initial-scale=1">
    <meta name=description content="mjdbc - small and efficient JDBC wrapper">
    <meta name=keywords content="jdbc, java, jdbi, mjdbc, sql, mapper, transaction, ORM">
    <meta name=author content="Mikhail Fursov and mjdbc contributors">
    <title>mJDBC - small and efficient JDBC wrapper</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="site.css">


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

</head>
<body>

<div class="bs-docs-header" id="content" tabindex="-1">
    <div class="container">
        <div class="logo-header-block">
            <div class="lang-switch-block"><a href="/" title="Switch to English">en</a> | <a href="/ru" title="Переключиться на русский">ru</a></div>
            <h1 class="logo-header">mJDBC<sub>v1.0.0</sub></h1>
        </div>
        <div class="header-text">Small and efficient <a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank">JDBC</a> wrapper
        </div>
        <div class="header-links-block">
            <a href="http://mvnrepository.com/artifact/com.github.mjdbc/mjdbc/1.0.0" class="btn btn-default btn-sm btn-header" target="_blank">Maven</a>
            <a href="http://github.com/mjdbc/mjdbc" class="btn btn-default btn-sm btn-header" target="_blank">GitHub</a>
        </div>
    </div>
</div>

<div class="container bs-docs-main">
    <div class="row">
        <!--Main Content -->
        <div class="col-xs-9">
            <section id="About" class="group">
                <h3>About</h3>
                <ul class="feature-list">
                    <li><i>Small</i> - no external dependencies. Jar size is less than 50kb.</li>
                    <li><i>Simple</i> - no special configuration required: 1 line of code to start.</li>
                    <li><i>Reliable</i> - all SQL statements are parsed and validated during initialization.</li>
                    <li><i>Flexible</i> - switch and use native JDBC interface directly when needed.</li>
                    <li><i>Fast</i> - no runtime overhead when compared to JDBC.</li>
                    <li><i>Transactional</i> - wrap any method into transaction.</li>
                    <li><i>Optimized</i> - SQL connection is requested during first statement execution.</li>
                    <li><i>Extensible</i> - add new data types or override the way built-in types are handled.</li>
                    <li><i>Measurable</i> - profile timings for all SQL queries and transactions.</li>
                    <li><i>Open</i> - fork the original code and change it.</li>
                </ul>
            </section>

            <section id="Install" class="group">
                <h3>Installation</h3>
                <div>
                    Add the following code to Maven project file:
                    <pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;com.github.mjdbc&lt;/groupId&gt;
    &lt;artifactId&gt;mjdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
                </div>
            </section>

            <section id="Examples" class="group">
                <div id="InstallExample" class="subgroup">
                    <h3>Examples</h3>
                    Example 1: SQL queries
                    <pre class="prettyprint">
// Step 1: Create mJDBC adapter for java.sql.DataSource
java.sql.DataSource ds = ...;
Db db = Db.newInstance(ds);

// Step 2: Design SQL interface
public interface UserSql {
    @Sql("INSERT INTO users(login) VALUES (:login)")
    int insertUser(@BindBean User user);

    @Sql("SELECT * FROM users WHERE login = :login")
    User getUserByLogin(@Bind("login") String login)
}

// Step 3: Define rules to map SQL results to Java objects
db.registerMapper(User.class, (r) -> {
    User user = new User();
    user.id = r.getInt("id");
    user.login = r.getString("login");
    ...
    return user;
};)

// Step 4: Get implementation for SQL interface
UserSql userSql = db.attachSql(UserSql.class);

// Step 5: Use SQL interface to perform queries
User user = userSql.getUserByLogin('login');</pre>

                    Example 2: Transactions
                    <pre class="prettyprint">
// Step 1: Create an interface with transactional methods
public interface UserDbi {
    void registerUser(User user);
}

// Step 2: Implement the interface
public class UserDbiImpl implements UserDbi {
    public void registerUser(User user) {
        User copy = userSql.getUserByLogin(user.login);
        assertNull(copy, "Пользователь уже существует: " + user.login);
        user.id = userSql.insertUser(user);
    }
}

// Step 3: Get proxy-adapter for the interface with transactions support
UserDbi userDbi = db.attachDbi(UserDbi.class, new UserDbiImpl());

// Step 4: Use the adapter
userDbi.registerUser(new User("root"));</pre>
                </div>
            </section>

            <section id="Adapter" class="group">
                <h3>mJDBC adapter</h3>
                <p>
                    To start using mJDBC create an instance of <i>com.github.mjdbc.Db</i> providing <i>javax.sql.DataSource</i> object to the factory method:
                </p>
                <pre class="prettyprint">
static Db newInstance(DataSource ds)</pre>
                <p>
                    <a href="#Transactions">Transactional interfaces</a> allows to execute multiple SQL requests within a single transaction: either all
                    of SQL request inside transaction will succeed or no effect on database state will done at all.
                </p>
                <p>
                    Any Java interface can be made transactional. To register the interface as transactional use the following method:
                </p>
                <pre class="prettyprint">
&lt;T&gt; T attachDbi(T impl, Class&lt;T&gt; dbiInterface)</pre>
                <p>
                    <a href="#Sql">SQL interfaces</a> - is a way to create maintainable set of SQL queries that checked for correctness during the interface registration.
                    SQL queries are written as <i>@Sql</i> annotations to methods and parameters are bound with <i>@Bind</i> and <i>@BindBean</i> classes.
                    When SQL interface is registered in mJDBC it returns a Proxy for the interface with SQL queries checked and implemented.
                </p>
                <pre class="prettyprint">
&lt;T&gt; T attachSql(Class&lt;T&gt; sqlInterface)</pre>
                <p>
                    <a href="#Binders"></a>Set of supported SQL interface parameter types can be extended by custom Java types by creating and registering new <i>DbBinder&lt;T&gt;</i> implementations,
                    which are responsible for Java objects mapping to parameters of <i>java.sql.PreparedStatement</i>
                </p>
                <pre class="prettyprint">
&lt;T&gt; void registerBinder(Class&lt;? extends T&gt; binderClass, DbBinder&lt;T&gt; binder)</pre>
                <p>
                    <a href="#Mappers">Return values</a> for SQL interfaces are instantiated using corresponding <i>DbMapper&lt;T&gt;</i> instances.
                    mJDBC supports by default primitive Java types, JDBC types and Java Lists. Support for custom return types can be added by using
                    implementing and registering new <i>DbMapper&lt;T&gt;</i> instance using the following method:
                </p>
                <pre class="prettyprint">
&lt;T&gt; void registerMapper(Class&lt;T&gt; mapperClass, DbMapper&lt;T&gt; mapper)</pre>
                <p>
                    mJDBC provides <a href="#LowLevelApi">low level API</a> to create and run queries without SQL or transactional interfaces still
                    utilising most of the benefits of mJDBC while having full access and control over JDBC objects.
                </p>
                <p>
                    <i>@Nullable</i> and <i>@NotNull</i> annotations are used throughout all API for strict control over <i>null</i> values.
                    Some API calls that may or may not return <i>null</i> are intentionally duplicated and users of the API are encouraged to follow null safety.
                </p>
                <pre class="prettyprint">
@Nullable
&lt;T&gt; T execute(@NotNull DbOp&lt;T&gt; op)

@NotNull
&lt;T&gt; T executeNN(@NotNull DbOpNN&lt;T&gt; op)

void executeV(@NotNull  DbOpV op)</pre>
                <p>
                    mJDBC automatically collects and provides simple <a href="#Profiling">profiling information</a> about
                    number of calls and total time spent in methods of SQL and transactional interfaces.
                    This information is available via <i>getTimers</i> method:
                </p>
                <pre class="prettyprint">
Map&lt;Method, DbTimer&gt; getTimers()</pre>
            </section>

            <section id="Transactions" class="group">
                <h3>Transactions</h3>
                mJDBC supports the following pattern for transactions:
                <ul class="spec-list">
                    <li>A developer defines and implement some Java interface.</li>
                    <li>mJDBC provides proxy-implementation for the given interface to manage transactional context on each interface method call
                        and forward all calls to the original implementation.
                    </li>
                    <li>The developer should use the proxy implementation for the interface provided by mJDBC.</li>
                </ul>
                <p>
                    Every method of the interface is a separate transaction: <i>commit</i> for is called after successful method call, <i>rollback</i> in case
                    if exception was thrown.
                </p>
                <p>
                    No new transaction created if one transactional interface method is called from within another.
                    The method called becomes a part of the upper-level transaction.
                </p>
                <p>
                    Implementation of transactions in mJDBC works the way that the real transaction as well as SQL connection request from <i>java.sql.DataSource</i>
                    occurs not during a call of the proxy method, but only during execution of the first real SQL call.
                    This way the methods of transactional interface that do not run any operations over database: use cache or trigger exceptions on arguments check
                    are executed without any database related overhead.
                </p>
                <p>
                    Transactional interfaces are simple Java interfaces: mJDBC does not require extending marker interfaces or use special annotations.
                    To get proxy implementation for a transactional interface the interface and its implementation must be registered using the following mJDBC call:
                </p>
                <pre class="prettyprint">
@NotNull
&lt;T&gt; T attachDbi(@NotNull T impl, @NotNull Class&lt;T&gt; dbiInterface)</pre>
                <p>The <i>dbi</i> prefix here stands for "database interface".</p>
                <p> Examples of transactional interfaces:
                    <i>
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/asset/dbi/SampleDbi.java" target="_blank" class="nw">SampleDbi</a>,
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/asset/dbi/SampleDbiImpl.java" target="_blank" class="nw">SampleDbiImpl</a>,
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/SamplesTest.java" target="_blank" class="nw">SamplesTest</a>.
                    </i>
                </p>
            </section>

            <section id="Sql" class="group">
                <h3>SQL interfaces</h3>
                <p>
                    SQL interface is a Java interface with every method associated with a single SQL request.
                    mJDBC provides implementation for SQL interface methods and handles method parameters and results mappings.
                </p>
                <p>
                    To create new SQL interface:
                </p>
                <ul class="spec-list">
                    <li>Create usual Java interface. Each method will be associated with SQL request.</li>
                    <li>Add native SQL query as <i>@Sql</i> annotation for every method.</li>
                    <li>Bind Java method parameters to named SQL parameters using <i>@Bind</i> or <i>@BindBean</i> annotations.</li>
                    <li>Get the interface implementation from mJDBC and use it to execute SQL queries.</li>
                </ul>
                <p>
                    SQL interface example:
                </p>
                <pre class="prettyprint">
public interface UserSql {
    @NotNull
    @GetGeneratedKeys
    @Sql("INSERT INTO users(login, first_name, last_name)
                    VALUES (:login, :firstName, :lastName)")
    UserId insertUser(@BindBean User user);

    @Nullable
    @Sql("SELECT * FROM users WHERE id = :id")
    User getUserById(@Bind("id") UserId id);

    @Nullable
    @Sql("SELECT * FROM users WHERE login = :login")
    User getUserByLogin(@Bind("login") String login);

    @Sql("SELECT COUNT(*) FROM users")
    int countUsers();
}</pre>
                <p>
                    To obtain SQL interface implementation use the following method:
                </p>
                <pre class="prettyprint">
@NotNull
&lt;T&gt; T attachSql(@NotNull Class &lt;T&gt; sqlInterface);
</pre>
                <p>
                    During this method call mJDBC will parse and check that all SQL parameters used in the request are present
                    and types of parameters and return value are supported.
                </p>
                <p>
                    All SQL parameters are named and are bound to Java parameters by their names. All names are prefixed with ':' symbol in SQL.
                </p>
                <p>
                    <i>@Bind</i> annotation is used to bind SQL parameters to Java method parameters. The annotation holds a name for corresponding
                    parameter in SQL query. <i>@BindBean</i> annotation is an alternative for <i>@Bind</i>: if used all parameters are derived from annotated
                    Java object fields. These fields must be public or have a public <i>get</i> methods.
                </p>
                <p>
                    mJDBC creates a separate <i>java.sql.PreparedStatement</i> object for each SQL interface method.
                    To bind Java or standard JDBC parameter types mJDBC calls corresponding methods of PreparedStatement object.
                    In order to use custom data types as SQL parameters there is a special API to register parameter binder class instances:
                    <a href="#Binders"> <i>DbBinder</i></a>, or implement interface for special set of additional data types supported by mJDBC:
                    <a href="https://github.com/mjdbc/mjdbc/blob/master/src/main/java/com/github/mjdbc/type/DbInt.java" target="_blank" class="nw"><i>DbInt</i></a>,
                    <a href="https://github.com/mjdbc/mjdbc/blob/master/src/main/java/com/github/mjdbc/type/DbString.java" target="_blank" class="nw"><i>DbString</i></a> etc.
                </p>
                <p>
                    To enable support for custom non-Java or non-JDBC return type for SQL interface methods implement and register <a href="#Mappers"><i>DbMapper</i></a> class.
                    This class will be used by mJDBC to map a single <i>java.sql.ResultSet</i> row into an instance of user defined type.
                    Lists (<i>java.util.List</i>) and basic Java and JDBC types are supported by mJDBC by default.
                </p>
                <p>
                    To return auto-generated SQL value use <i>@GetGeneratedKeys</i> annotation for SQL method.
                    Use of <i>@GetGeneratedKeys</i> is optional for SQL statements that starts from "INSERT " prefix:
                    mJDBC will apply <i>@GetGeneratedKeys</i> to them automatically.
                </p>
                <p>
                    In case if Java parameter is iterator (<i>java.util.Iterator</i>),
                    collection (<i>java.util.Iterable</i>) or Java <i>array</i> instance mJDBC will use <a href="#Batch">batch mode</a> to execute the query.
                </p>

            </section>

            <section id="Binders" class="group">
                <h3>SQL параметры</h3>
                <p>
                    Для работы с параметрами <a href="#Sql">SQL интерфейса</a> используются интерфейс <i>DbBinder</i> и аннотации <i>@Bind</i> и <i>@BindBean</i>.
                    Интерфейс DbBinder описывает как параметр указанного Java типа должен быть сериализован в качестве параметра <i>java.sql.PreparedStatements</i>:
                </p>
                <pre class="prettyprint">
public interface DbBinder&lt;T&gt; {
    void bind(PreparedStatement statement, int idx, T value)
}</pre>
                <p>При исполнении SQL-запроса mJDBC автоматически подбирает подходящую реализацию <i>DbBinder</i> из набора всех зарегистрированных.
                    При этом, приоритет поиска <i>DbBinder</i> следующий:</p>
                <ul class="spec-list">
                    <li>Точное совпадение с типом класса параметра.</li>
                    <li>Точное совпадение с типом родительского класса параметра.</li>
                    <li>Совпадение с одним из имплементированных интерфейсов.</li>
                </ul>
                <p>
                    При наличии более одного подходящего интерфейса производится исключение: <i>java.lang.IllegalArgumentException.</i>
                    Процесс подбора <i>DbBinder</i> происходит на момент регистрации SQL интерфейса в mJDBC.
                </p>
                <p>Для регистрации новых реализаций <i>DbBinder</i> используется метод</p>
                <pre class="prettyprint">
&lt;T&gt; void registerBinder(Class&lt;? extends T&gt; binderClass, DbBinder&lt;T&gt; binder)</pre>
                <p>
                    Аннотация <i>@Bind</i> используется для указания точного имени параметра <i>java.sql.PreparedStatement</i>.
                </p>
                <p>
                    Аннотация <i>@BindBean</i> говорит о том, что имена параметров должны совпадать с именами публичных полей или <i>get</i>-методов объекта.
                    В текущей версии mJDBC параметр описанный при помощи <i>@BindBean</i> должен быть единственным параметром интерфейса.
                </p>
                <p>
                    В случае, если SQL запрос содержит больше именованных параметров, чем доступно из данных <i>@Bind</i> и <i>@BindBean</i> аннотаций,
                    производится исключение. Лишние параметры со стороны Java игнорируются. Имена параметров могут содержать только символы Java идентификаторов.
                </p>
                <p>Проверка на полноту и корректность SQL параметров происходит в момент регистрации SQL-интерфейса.</p>

            </section>

            <section id="Mappers" class="group">
                <h3>SQL результаты</h3>
                <p>
                    mJDBC необходимо знать каким образом преобразовывать возвращаемые SQL интерфейсом данные в Java объекты.
                    По умолчанию mJDBC поддерживает все примитивные Java типы и их объектные аналоги, типы <i>java.sql.Date</i>, <i>java.sql.Timestamp</i>, <i>java.util.Date</i>,
                    <i>java.math.BigDecimal</i> и интерфейс списков <i>java.util.List</i>. Для списков в качестве реализации используется <i>java.util.ArrayList</i>.
                </p>
                <p>
                    Для того, чтобы расширить диапазон поддерживаемых типов необходимо зарегистрировать реализацию интерфейса <i>DbMapper</i>, которая из текущей позиции
                    <i>ResultSet</i> создаст и заполнит нужными значениями экземпляр возвращаемого объекта:
                </p>
                    <pre class="prettyprint">
public interface DbMapper&lt;T&gt; {
    T map(@NotNull java.sql.ResultSet r) throws SQLException;
}</pre>

                <p>Например: </p>
                <pre class="prettyprint">
DbMapper&lt;User&gt; mapper = (r) -&gt; {
    User user = new User();
    user.id = new UserId(r.getInt("id"));
    user.login = r.getString("login");
    return user;
}
db.registerMapper(User.class, mapper);
</pre>
                <p>
                    Существует несколько техник, которые позволяют mJDBC автоматически находить необходимые реализации <i>DbMapper</i> для возвращаемых методами SQL интерфесов типов,
                    делая их ручную регистрацию опциональной. Для этого, для возвращаемого типа <i>T</i> должно быть выполнено следующее условие:
                </p>
                <ul class="spec-list">
                    <li>Присутствует публичное статическое финальное поле с аннотацией <i>@Mapper</i> и типом <i>DbMapper&lt;T&gt;</i></li>
                </ul>
                <p>
                    Автоматический поиск нужного экземпляра происходит при условии, что для типа <i>T</i> нет экземпляра <i>DbMapper&lt;T&gt;</i> зарегистрированного вручную.
                </p>
                <p>
                    Поиск происходит на момент регистрации SQL интерфейса.
                    В случае, если в результате поиска найдено 2 или более кандидата на роль <i>DbMapper</i>, выбрасывается исключение и регистрации SQL-интерфейса не происходит.</p>
                <p>
                    Повторные прямые вызовы метода <i>registerMapper</i> допускаются и приводят к регистрации нового обработчика <i>DbMapper</i> для указанного типа.
                </p>
            </section>

            <section id="Batch" class="group">
                <h3>Batch операции</h3>
                <p>
                    Batch операции используются для оптимизированного исполнения серии однотипных операций над базой данных. Например:
                </p>
                <pre class="prettyprint">
@Sql("UPDATE users SET score = :score WHERE id = :id")
void updateScore(@Bind("id") int[] ids, @Bind("score") int score);

@Sql(&quot;UPDATE users SET score = :score WHERE id = :id&quot;)
void updateScore(@BindBean List&lt;User&gt; users);

@Sql(&quot;INSERT INTO users(login, score) VALUES (:login, :score)&quot;)
void insertUsers(@BindBean List&lt;User&gt; users);</pre>
                <p>
                    При этом mJDBC использует один экземпляр <i>java.sql.PreparedStatement</i> с помощью которого исполняются стандартные JDBC
                    <i>addBatch/executeBatch</i> операции.
                </p>
                <p>Количество вызовов метода <i>addBatch</i> перед каждым <i>executeBatch</i> задается параметром <i>batchChunkSize</i> аннотации <i>@Sql</i>.
                    Значение по умолчанию для этого параметра: <i>Integer.MAX_VALUE</i>.</p>
                <pre class="prettyprint">
@Sql(value = &quot;UPDATE users SET score = :score WHERE id = :id&quot;,
     batchChunkSize = 100)
void updateScore(@BindBean List&lt;User&gt; users);

                </pre>
                <p>
                    Batch операции поддерживаются для параметров SQL-интерфейса описанных с использованием аннотаций <i>@Bind</i> и <i>@BindBean</i>.
                    При этом допускается присутствие только одного batch-параметра в запросе.
                </p>
                <p>
                    Batch-параметр определяется по принадлежности к одному из следующих типов: Java массив, <i>java.util.Iterable</i> или <i>java.util.Iterator</i>.
                </p>
            </section>

            <section id="Profiling" class="group">
                <h3>Профилировка</h3>
                mJDBC отслеживает суммарное время исполнения и количество вызовов для всех зарегистрированных SQL-запросов и транзакционных методов.
                Для доступа к этой информации используется метод
                <pre class="prettyprint">
@NotNull
Map&lt;Method, DbTimer&gt; getTimers();</pre>
                где <i>DbTimer</i> является следующей структурой:
                <pre class="prettyprint">
public final class DbTimer {
    @NotNull
    private final Method method;

    protected volatile long invocationCount;

    protected volatile long totalTimeInNanos;</pre>
            </section>

            <section id="LowLevelApi" class="group">
                <h3>Низкоуровневый интерфейс</h3>
                <div class="subgroup">
                    <h4 id="DbOp">Транзакции</h4>
                    <p>
                        mJDBC позволяет работать с транзакциями и SQL запросами без использования транзакционных и SQL интерфейсов,
                        что может быть удобно для небольших приложений, либо если текущий
                        функционал интерфейсов mJDBC недостаточен.
                    </p>
                    <p>
                        Для того, чтобы выполнить транзакционную SQL операцию без использования SQL интерфейса можно использовать одни из следующих методов mJDBC:
                    </p>
                <pre class="prettyprint">
@Nullable
&lt;T&gt; T execute(@NotNull DbOp&lt;T&gt; op);

@NotNull
&lt;T&gt; T executeNN(@NotNull DbOpNN&lt;T&gt; op);

void executeV(@NotNull DbOpV op);</pre>
                    <p>При вызове любого из этих методов имплементация интерфейса <i>DbOp</i> будет исполнена как отдельная транзакция,
                        также как исполняется отдельный метод транзакционного интерфейса.</p>
                <pre class="prettyprint">
/**
 * Database operation with @Nullable result.
 */
public interface DbOp&lt;T&gt; {
    @Nullable
    T run(@NotNull DbConnection c) throws Exception;
}

/**
 * Database operation with no result.
 */
public interface DbOpV {
    void run(@NotNull DbConnection c) throws Exception;
}

/**
 * Database operation with @NotNull result.
 */
public interface DbOpNN&lt;T&gt; {
    @NotNull
    T run(@NotNull DbConnection c) throws Exception;
}</pre>
                    <p>Присутствие трех различных интерфейсов отличающихся лишь типом возвращаемого результата сделано для
                        удобства использования и возможности использования статических анализаторов кода.</p>
                    <p>Параметр <i>DbConnection</i> предоставляет прямой доступ к <i>java.sql.Connection</i>
                        и используется mJDBC для использования совместно с классом <i>DbPreparedStatement</i> описанным ниже.</p>
                    <p>В случае, если верхнеуровневый <i>DbOp.run</i> метод завершается без выбрасывания исключения, у текущей транзакции вызывается метод <i>commit</i>.
                        Иначе вызывается метод <i>rollback</i>. Вложенные вызовы <i>execute(DbOp)</i> не приводят к созданию новых транзакций и встраиваются в
                        транзакционный контекст вызывающего метода.</p>
                </div>
                <div class="subgroup">
                    <h4 id="DbStatement">SQL запросы</h4>
                    <p>
                        Для создания SQL запросов без использования SQL интерфейса mJDBC предоставляет класс <i>DbPreparedStatement</i>. Этот класс является оболочкой и
                        предоставляет полный доступ к <i>java.sql.PreparedStatement</i>, а также предоставляет следующий дополнительный функционал:
                    </p>
                    <ul class="spec-list">
                        <li>Работа с именованными параметрами.</li>
                        <li>Проверка корректности привязки параметров на момент создания.</li>
                        <li>Отображения результатов в Java объекты при помощи <i>DbMapper</i>.</li>
                        <li>Автоматическое освобождение ресурсов при завершении транзакции/соединения.</li>
                    </ul>
                    <p>
                        Примеры использования <i>DbPreparedStatement</i> совместно с <i>DbOp</i>:
                    </p>
                    <pre class="prettyprint">
List&lt;User&gt; users = db.execute(c -&gt;
    new DbPreparedStatement&lt;&gt;(c, &quot;SELECT * FROM users&quot;, User.class)
        .queryList());</pre>

            <pre class="prettyprint">
User user = db.execute(c -&gt;
    new DbPreparedStatement&lt;&gt;(c, &quot;SELECT * FROM users WHERE login = :login&quot;, User.class).set("login", "admin").query());</pre>
                </div>
                <p>Все операции с <i>DbPreparedStatement</i> выполненные внутри <i>DbOp</i> метода являются частью одной транзакции.
                    Все связанные с ними ресурсы отслеживаются mJDBC и автоматически высвобождаются по завершении транзакции.</p>

            </section>

            <section id="Recommendations" class="group">
                <h3>Рекомендации</h3>
                <ul class="spec-list">
                    <li>Используйте примеры с открытым исходным кодом:
                        <a href="https://github.com/mjdbc/mjdbc/tree/master/src/test/java/com/github/mjdbc/test" target="_blank">тесты</a>,
                        <a href="https://github.com/mfursov/wicket7template/tree/master/src/main/java/com/github/mfursov/w7/db" target="_blank">другие проекты</a> на GitHub.
                    </li>
                    <li>Используйте пулы для соединения с базой данных. Пример: <a href="https://brettwooldridge.github.io/HikariCP/" target="_blank">HikariCP</a></li>
                </ul>
            </section>

        </div>
        <!--Nav Bar -->
        <nav class="col-xs-3 bs-docs-sidebar">
            <ul id="sidebar" class="nav nav-stacked fixed">
                <li><a href="#About">About</a></li>
                <li><a href="#Install">Installation</a></li>
                <li><a href="#Examples">Examples</a></li>
                <li><a href="#Adapter">mJDBC adapter</a></li>
                <li><a href="#Transactions">Transactions</a></li>
                <li><a href="#Sql">SQL interfaces</a></li>
                <li><a href="#Binders">SQL parameters</a></li>
                <li><a href="#Mappers">SQL results</a></li>
                <li><a href="#Batch">Batch operations</a></li>
                <li><a href="#Profiling">Profiling</a></li>
                <li><a href="#LowLevelApi">Low level API</a>
                    <ul class="nav nav-stacked">
                        <li><a href="#DbOp">Transactions</a></li>
                        <li><a href="#DbStatement">SQL queries</a></li>
                    </ul>
                </li>
                <li><a href="#Recommendations">Recommendations</a></li>
            </ul>
        </nav>
    </div>
</div>

<script>
    $('body').scrollspy({
        target: '.bs-docs-sidebar',
        offset: 40
    });
</script>

</body>
</html>
