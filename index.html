<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset=utf-8>
    <meta http-equiv=X-UA-Compatible content="IE=edge">
    <meta name=viewport content="width=device-width,initial-scale=1">
    <meta name=description content="mjdbc - small and efficient JDBC wrapper">
    <meta name=keywords content="jdbc, java, jdbi, mjdbc, sql, mapper, transaction, ORM">
    <meta name=author content="Mikhail Fursov and mjdbc contributors">
    <title>mJDBC - small and efficient JDBC wrapper</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="site.css">


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

</head>
<body>

<div class="bs-docs-header" id="content" tabindex="-1">
    <div class="container">
        <h1 class="logo-header">mJDBC<sub>v1.0.0</sub></h1>
        <div class="header-text">компактная, простая и удобная библиотека для
            <a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank">JDBC</a>
        </div>
        <div class="header-links-block">
            <a href="" class="btn btn-default btn-sm btn-header" target="_blank">Maven</a>
            <a href="http://github.com/mjdbc/mjdbc" class="btn btn-default btn-sm btn-header" target="_blank">GitHub</a>
        </div>
    </div>
</div>

<div class="container bs-docs-main">
    <div class="row">
        <!--Main Content -->
        <div class="col-xs-9">
            <section id="GroupAbout" class="group">
                <h3>О библиотеке</h3>
                <ul class="feature-list">
                    <li><i>Компактность</i> - около 50кб, нет дополнительных зависимостей.</li>
                    <li><i>Простота</i> - не нужно учить лишнее. Инициализация: от 1 строки кода.</li>
                    <li><i>Надеждность</i> - SQL запросы проверяются на момент старта приложения.</li>
                    <li><i>Гибкость</i> - доступ к низкоуровневому функционалу JDBC.</li>
                    <li><i>Производительность</i> - нет дополнительных вычислительных расходов по сравнению с JDBC.</li>
                    <li><i>Транзакционность</i> - методы могут выполнять роль транзакций.</li>
                    <li><i>Скорость</i> - SQL соедиенение открывается в момент исполнения первого реального запроса.</li>
                    <li><i>Расширяемость</i> - регистрация новых типов данных, переопределение существующих.</li>
                    <li><i>Профилировка</i> - доступ метрикам исполнения запросов и транзакций.</li>
                    <li><i>Открытость</i> - открытый исходный код: возможность изменять и исправлять.</li>
                    <li><i>Надежность</i> - используется в реальных проектах.</li>
                </ul>
            </section>
            <section id="GroupInstall" class="group">
                <h3>Установка</h3>
                <div>
                    Добавьте следующий код в проектный файл Maven:
                    <pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;com.github.mjdbc&lt;/groupId&gt;
    &lt;artifactId&gt;mjdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
                </div>
            </section>
            <section id="GroupExamples" class="group">
                <div id="GroupInstallExample" class="subgroup">
                    <h3>Примеры использования</h3>
                    Пример 1: SQL запросы
                    <pre class="prettyprint">
// Шаг 1: Создаем mJDBC адаптер для java.sql.DataSource
java.sql.DataSource ds = ...;
Db db = Db.newInstance(ds);

// Шаг 2: Описываем SQL интерфейс
public interface UserSql {
    @Sql("INSERT INTO users(login) VALUES (:login)")
    int insertUser(@BindBean User user);

    @Sql("SELECT * FROM users WHERE login = :login")
    User getUserByLogin(@Bind("login") String login)
}

// Шаг 3: Определяем правила считывания структур из ResultSet
db.registerMapper(User.class, (r) -> {
    User user = new User();
    user.id = r.getInt("id");
    user.login = r.getString("login");
    ...
    return user;
};)

// Шаг 4: Получаем реализацию SQL интерфейса
UserSql userSql = db.attachSql(UserSql.class);

// Шаг 5: Используем SQL интерфейс для исполнения запросов
User user = userSql.getUserByLogin('login');</pre>

                    Пример 2: Транзакции
                    <pre class="prettyprint">
// Шаг 1: Создаем интерфейс с транзакционными методами
public interface UserDbi {
    void registerUser(User user);
}

// Шаг 2: Имплементируем интерфейс
public class UserDbiImpl implements UserDbi {
    public void registerUser(User user) {
        User copy = userSql.getUserByLogin(user.login);
        assertNull(copy, "Пользователь уже существует: " + user.login);
        user.id = userSql.insertUser(user);
    }
}

// Шаг 3: Получаем транзакционный прокси-адаптер для интерфейса
UserDbi userDbi = db.attachDbi(UserDbi.class, new UserDbiImpl());

// Шаг 4: Используем адаптер для вызова методов имплементации
userDbi.registerUser(new User("root"));</pre>
                </div>
            </section>
            <section id="GroupAdapter" class="group">
                <h3>Обзор mJDBC адаптера</h3>
                <p>
                    Для того, чтобы начать использовать mJDBC необходимо создать адаптер типа <i>com.github.mjdbc.Db</i> поверх экземпляра <i>javax.sql.DataSource</i>.
                    Для этого нужно использовать статический метод-фабрику:</p>
                <pre class="prettyprint">
static Db newInstance(DataSource ds)</pre>
                <p><a href="#GroupTransactions"> Транзакционные интерфейсы</a> позволяют выполнить серию SQL-запросов как единую транзакцию давая гарантию, что либо все SQL операции внутри
                    транзакции будут завершены успешено, либо ни одна из них не будет иметь эффект при завершении транзакции.
                    Для регистрации транзакционных интерфейсов используйте следующий метод:
                </p>
                <pre class="prettyprint">
&lt;T&gt; T attachDbi(T impl, Class&lt;T&gt; dbiInterface)</pre>
                <p><a href="#GroupSql">SQL интерфейсы</a> - выразительный способ описывать SQL запросы проверяемые на корректность на момент регистрации интерфейса.
                    Метод регистрации интерфейса возвращает Proxy-класс с реализацией SQL методов описанных в качестве @Sql аннотаций.
                <pre class="prettyprint">
&lt;T&gt; T attachSql(Class&lt;T&gt; sqlInterface)</pre>
                <p><a href="#GroupBinders">Типы параметров</a> для SQL интерфейсов могут быть расширены при помощи регистрации реализаций интерфейса <i>DbBinder</i>,
                    который обеспечивает отображение значения параметра в JDBC параметр для <i>java.sql.PreparedStatement</i></p>
                <pre class="prettyprint">
&lt;T&gt; void registerBinder(Class&lt;? extends T&gt; binderClass, DbBinder&lt;T&gt; binder)</pre>
                За <a href="#GroupMappers">возвращаемые значения</a> SQL запросов отвечают зарегистрированные экземпляры класса <i>DbMapper</i>.
                mJDBC поддерживает примитивные Java типы, JDBC типы и списки. Поддержка новых типов может быть расширена за счет использования следующего метода:
                <pre class="prettyprint">
&lt;T&gt; void registerMapper(Class&lt;T&gt; mapperClass, DbMapper&lt;T&gt; mapper)</pre>
                <p>Помимо создания транзакционных и SQL интерфейсов mJDBC позволяет создавать <a href="#GroupLowLevelApi">прямые запросы</a> к базе.
                    При этом вызванный метод будет обернут в транзакцию так, если бы использовался транзацкионный интерфейс.</p>
                <p>Внутри у метода будет доступ как к управляемому JDBC соединению (<i>DbConnection</i>), так и к <i>DbPreparedStatement</i> классу который поддерживает
                    работу с <i>DbBinder</i>/<i>DbMapper</i> и именованными параметрами. Помимо этого будет доступ к реальным JDBC объектам.</p>
                <p>Все вызовы mJDBC аннотированы с <i>@Nullable</i>/<i>@NotNull</i> аннотациями для жесткого контроля работы с нулевыми значениями.
                    Более того, операции которые могут и не могут возвращать нулевые значения разделены. </p>
                <pre class="prettyprint">
@Nullable
&lt;T&gt; T execute(@NotNull DbOp&lt;T&gt; op)

@NotNull
&lt;T&gt; T executeNN(@NotNull DbOpNN&lt;T&gt; op)

void executeV(@NotNull  DbOpV op)
                </pre>
                <p>
                    Доступ к простейшей <a href="#GroupProfiling">профилировочной информации</a> о числе вызовов и суммарном времени исполнения транзационных методов и SQL-запросов
                    можно получить используя метод <i>getTimers</i>:
                </p>
                <pre class="prettyprint">
Map&lt;Method, DbTimer&gt; getTimers()</pre>
            </section>
            <section id="GroupTransactions" class="group">
                <h3>Транзакции</h3>
                mJDBC предоставляет следующий механизм поддержки транзакций:
                <ul class="spec-list">
                    <li>Разработчик описывает и имплементирует Java интерфейс</li>
                    <li>mJDBC предоставляет свою прокси-имплементацию этого интерфейса, при вызове методов которого
                        создаются транзакции и вызывается оригинальная имплементация
                    </li>
                    <li>Разработчик работает с proxy-имплементацией своего интерфейса.</li>
                </ul>
                <p>
                    Каждый метод интерфейса представляет из себя отдельную транзакцию: метод <i>commit</i> для транзакции вызывается при успешном завершении метода.
                    Метод <i>rollback</i>, если имплементация производит исключение.
                </p>
                <p>
                    В случае, если из один транзакционный метод вызывает другой транзакционный метод, новой транзакции не создается.
                    Вызванный метод становится частью верхнеуровневой транзакции.
                </p>
                <p>
                    Реализация транзакций mJDBC устроена так, что реальная транзакция, так же как и запрос соединения и <i>java.sql.DataSource</i> происходит не в момент вызова прокси-метода,
                    а при первом реальном исполнении SQL. Таким образом, вызовы которые не производят операций с базой, например, используют кэш или проверяют аргументы и
                    возвращают код ошибки, выполняются значительно быстрее.
                </p>
                <p>
                    Транзакционные интерфейсы ничем не отличаются от обычных Java интерфейсов: mJDBC не требует наследования маркерных интерфейсов или наличия аннотаций.
                    Для получения имплементации транзакционного интерфейса необходимо зарегистрировать его и его имплементацию при помощи вызова:
                </p>
                <pre class="prettyprint">
@NotNull
&lt;T&gt; T attachDbi(@NotNull T impl, @NotNull Class&lt;T&gt; dbiInterface)</pre>
                <p>Сокращение <i>dbi</i> здесь означает: database interface.</p>
                <p> Пример использования транзакционного dbi интерфейса:
                    <i>
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/asset/dbi/SampleDbi.java" target="_blank" class="nw">SampleDbi</a>,
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/asset/dbi/SampleDbiImpl.java" target="_blank" class="nw">SampleDbiImpl</a>,
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/SamplesTest.java" target="_blank" class="nw">SamplesTest</a>.
                    </i>
                </p>
            </section>
            <section id="GroupSql" class="group">
                <h3>SQL интерфейс</h3>
                <p>
                    SQL интерфейс - это Java интерфейс, где каждый метод является отдельным SQL запросом. mJDBC создает готовую к использованию имплементацию для таких интерфейсов.
                    Разработчик использует созданную mJDBC имплементацию для исполнения операций с базой данных вызывая методы интерфейса.</p>
                <p>
                    Для того, чтобы описать SQL интерфейс нужно:
                </p>
                <ul class="spec-list">
                    <li>Создать обычный Java интерфейс, где каждый метод будет соответствовать одному SQL запросу.</li>
                    <li>Написать для каждого метода реальный SQL запрос на языке поддерживаемым используемой базой данных и поместить этот запрос в виде аннотации <i>@Sql</i> к методу.</li>
                    <li>Привязать параметры Java метода к параметрам SQL запроса используя <i>@Bind</i> и <i>@BindBean</i> аннотации.</li>
                    <li>Получить имплементацию описанного интерфейса у mJDBC.</li>
                </ul>
                Пример SQL интерфейса:
                <pre class="prettyprint">public interface UserSql {
    @NotNull
    @GetGeneratedKeys
    @Sql("INSERT INTO users(login, first_name, last_name)
                    VALUES (:login, :firstName, :lastName)")
    UserId insertUser(@BindBean User user);

    @Nullable
    @Sql("SELECT * FROM users WHERE id = :id")
    User getUserById(@Bind("id") UserId id);

    @Nullable
    @Sql("SELECT * FROM users WHERE login = :login")
    User getUserByLogin(@Bind("login") String login);

    @Sql("SELECT COUNT(*) FROM users")
    int countUsers();
}</pre>
                <p>
                    Для того, чтобы получить реализацию этого интерфейса следует вызвать следующий метод mJDBC:
                </p>
                <pre class="prettyprint">
@NotNull
&lt;T&gt; T attachSql(@NotNull Class &lt;T&gt; sqlInterface);
</pre>
                <p>
                    При этом произойдет парсинг и проверка запроса на предмет корректности подстановки параметров и возвращаемых значений.
                </p>
                <p>
                    Подставляемые параметры в SQL запросе именованы и имеют префикс к имени в виде двоеточия: ':'.
                </p>
                <p>
                    Соответствие SQL и Java параметров строится по их именам. Для этого для Java параметров используется аннотация <i>@Bind</i>
                    в которой указывается имя соответствующего SQL параметра. Также, для объектных типов возможно использование аннотации @BindBean:
                    в этом случае в качестве параметров SQL будут подставлены имена и значения полей Java объекта.
                    Поля объекта должны быть публичными, либо иметь публичные <i>get</i>-методы.
                </p>
                <p>
                    Исполнение каждого SQL запроса приведет к созданию и исполнению <i>java.sql.PreparedStatement</i>. При этом, для параметров имеющих базовые
                    Java или JDBC типы вызовется соответствующий метод из PreparedStatement. Для того, чтобы в качестве параметров использовать свои собственные
                    типы данных необходимо зарегистрировать в mJDBC механизм отображения параметров в виде имплементации класса
                    <a href="#GroupBinders"> <i>DbBinder</i></a>, либо унаследовать интерфейс описывающий поддерживаемый mJDBC тип:
                    <a href="https://github.com/mjdbc/mjdbc/blob/master/src/main/java/com/github/mjdbc/type/DbInt.java" target="_blank" class="nw"><i>DbInt</i></a>,
                    <a href="https://github.com/mjdbc/mjdbc/blob/master/src/main/java/com/github/mjdbc/type/DbString.java" target="_blank" class="nw"><i>DbString</i></a> etc.
                </p>
                <p>
                    В случае, если SQL запрос возвращает нестандартный тип данных необходимо зарегистрировать его отображение из <i>java.sql.ResultSet</i> при помощи
                    реализации класса <a href="#GroupMappers"><i>DbMapper</i></a>. Списки (<i>java.util.List</i>) и базовые Java и JDBC типы поддерживаются
                    mJDBC автоматически.
                </p>
                <p>
                    Для возврата авто-генерируемого значения, можно использовать аннотацию <i>@GetGeneratedKeys</i>.
                    Использование <i>@GetGeneratedKeys</i> в коде не обязательно для запросов начинающихся с префикса "INSERT ":
                    для них возврат генерируемого значения происходит по умолчанию.
                </p>
                <p>
                    В случае, если Java параметр является коллекцией, итератором или массивом, вместо одного запроса будет выполнена серия <a href="#GroupBatch">batch-запросов</a>.
                </p>

            </section>
            <section id="GroupBinders" class="group">
                <h3>SQL параметры</h3>
                <p>
                    Для работы с параметрами <a href="#GroupSql">SQL интерфейса</a> используются интерфейс <i>DbBinder</i> и аннотации <i>@Bind</i> и <i>@BindBean</i>.
                    Интерфейс DbBinder описывает как параметр указанного Java типа должен быть сериализован в качестве параметра <i>java.sql.PreparedStatements</i>:
                </p>
                <pre class="prettyprint">
public interface DbBinder&lt;T&gt; {
    void bind(PreparedStatement statement, int idx, T value)
}</pre>
                <p>При исполнении SQL-запроса mJDBC автоматически подбирает подходящую реализацию <i>DbBinder</i> из набора всех зарегистрированных.
                    При этом, приоритет поиска <i>DbBinder</i> следующий:</p>
                <ul class="spec-list">
                    <li>Точное совпадение с типом класса параметра.</li>
                    <li>Точное совпадение с типом родительского класса параметра.</li>
                    <li>Совпадение с одним из имплементированных интерфейсов.</li>
                </ul>
                <p>
                    При наличии более одного подходящего интерфейса производится исключение: <i>java.lang.IllegalArgumentException.</i>
                    Процесс подбора <i>DbBinder</i> происходит на момент регистрации SQL интерфейса в mJDBC.
                </p>
                <p>Для регистрации новых реализаций <i>DbBinder</i> используется метод</p>
                <pre class="prettyprint">
&lt;T&gt; void registerBinder(Class&lt;? extends T&gt; binderClass, DbBinder&lt;T&gt; binder)</pre>
                <p>
                    Аннотация <i>@Bind</i> используется для указания точного имени параметра <i>java.sql.PreparedStatement</i>.
                </p>
                <p>
                    Аннотация <i>@BindBean</i> говорит о том, что имена параметров должны совпадать с именами публичных полей или <i>get</i>-методов объекта.
                    В текущей версии mJDBC параметр описанный при помощи <i>@BindBean</i> должен быть единственным параметром интерфейса.
                </p>
                <p>
                    В случае, если SQL запрос содержит больше именованных параметров, чем доступно при из данных <i>@Bind</i> и <i>@BindBean</i> аннотаций,
                    производится исключение. Лишние параметры со стороны Java игнорируются. Имена параметров могут содержать только символы Java идентификаторов.
                </p>
                <p>Проверка на полноту и корректность SQL параметров происходит в момент регистрации SQL-интерфейса.</p>

            </section>
            <section id="GroupMappers" class="group">
                <h3>SQL результаты</h3>
            </section>
            <section id="GroupBatch" class="group">
                <h3>Batch операции</h3>
            </section>
            <section id="GroupProfiling" class="group">
                <h3>Профилировка</h3>
            </section>
            <section id="GroupLowLevelApi" class="group">
                <h3>Низкоуровневый интерфейс</h3>
            </section>
            <section id="GroupRecommendations" class="group">
                <h3>Рекомендации</h3>
            </section>
        </div>
        <!--Nav Bar -->
        <nav class="col-xs-3 bs-docs-sidebar">
            <ul id="sidebar" class="nav nav-stacked fixed">
                <li><a href="#GroupAbout">О библиотеке</a></li>
                <li><a href="#GroupInstall">Установка</a></li>
                <li><a href="#GroupExamples">Примеры использования</a></li>
                <li><a href="#GroupAdapter">Обзор mJDBC адаптера</a></li>
                <li><a href="#GroupTransactions">Транзакции</a></li>
                <li><a href="#GroupSql">SQL интерфейс</a></li>
                <li><a href="#GroupBinders">SQL параметры</a></li>
                <li><a href="#GroupMappers">SQL результаты</a></li>
                <li><a href="#GroupBatch">Batch операции</a></li>
                <li><a href="#GroupProfiling">Профилировка</a></li>
                <li><a href="#GroupLowLevelApi">Низкоуровневый интерфейс</a></li>
                <li><a href="#GroupRecommendations">Рекомендации</a></li>
            </ul>
        </nav>
    </div>
</div>
<script>
    $('body').scrollspy({
        target: '.bs-docs-sidebar',
        offset: 40
    });
</script>
</body>
</html>
