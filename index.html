<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset=utf-8>
    <meta http-equiv=X-UA-Compatible content="IE=edge">
    <meta name=viewport content="width=device-width,initial-scale=1">
    <meta name=description content="mjdbc - small and efficient JDBC wrapper">
    <meta name=keywords content="jdbc, java, jdbi, mjdbc, sql, mapper, transaction, ORM">
    <meta name=author content="Mikhail Fursov and mjdbc contributors">
    <title>mJDBC - small and efficient JDBC wrapper</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" crossorigin="anonymous">
    <link rel="stylesheet" href="site.css">


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

</head>
<body>

<div class="bs-docs-header" id="content" tabindex="-1">
    <div class="container">
        <div class="logo-header-block">
            <div class="lang-switch-block"><a href="/" title="Switch to English">en</a> | <a href="/ru" title="Переключиться на русский">ru</a></div>
            <h1 class="logo-header">mJDBC<sub>v1.0.0</sub></h1>
        </div>
        <div class="header-text">Small and efficient <a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank">JDBC</a> wrapper
        </div>
        <div class="header-links-block">
            <a href="http://mvnrepository.com/artifact/com.github.mjdbc/mjdbc/1.0.0" class="btn btn-default btn-sm btn-header" target="_blank">Maven</a>
            <a href="http://github.com/mjdbc/mjdbc" class="btn btn-default btn-sm btn-header" target="_blank">GitHub</a>
        </div>
    </div>
</div>

<div class="container bs-docs-main">
    <div class="row">
        <!--Main Content -->
        <div class="col-xs-9">
            <section id="About" class="group">
                <h3>About</h3>
                <ul class="feature-list">
                    <li><i>Small</i> - no external dependencies. Jar size is less than 50kb.</li>
                    <li><i>Simple</i> - no special configuration required: 1 line of code to start.</li>
                    <li><i>Reliable</i> - all SQL statements are parsed and validated during initialization.</li>
                    <li><i>Flexible</i> - switch and use native JDBC interface directly when needed.</li>
                    <li><i>Fast</i> - no runtime overhead when compared to JDBC.</li>
                    <li><i>Transactional</i> - wrap any method into transaction.</li>
                    <li><i>Optimized</i> - SQL connection is requested during first statement execution.</li>
                    <li><i>Extensible</i> - add new data types or override the way built-in types are handled.</li>
                    <li><i>Measurable</i> - profile timings for all SQL queries and transactions.</li>
                    <li><i>Open</i> - fork the original code and change it.</li>
                </ul>
            </section>

            <section id="Install" class="group">
                <h3>Installation</h3>
                <div>
                    Add the following code to Maven project file:
                    <pre class="prettyprint">
&lt;dependency&gt;
    &lt;groupId&gt;com.github.mjdbc&lt;/groupId&gt;
    &lt;artifactId&gt;mjdbc&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
                </div>
            </section>

            <section id="Examples" class="group">
                <div id="InstallExample" class="subgroup">
                    <h3>Examples</h3>
                    Example 1: SQL queries
                    <pre class="prettyprint">
// Step 1: Create mJDBC adapter for java.sql.DataSource
java.sql.DataSource ds = ...;
Db db = Db.newInstance(ds);

// Step 2: Design SQL interface
public interface UserSql {
    @Sql("INSERT INTO users(login) VALUES (:login)")
    int insertUser(@BindBean User user);

    @Sql("SELECT * FROM users WHERE login = :login")
    User getUserByLogin(@Bind("login") String login)
}

// Step 3: Define rules to map SQL results to Java objects
db.registerMapper(User.class, (r) -> {
    User user = new User();
    user.id = r.getInt("id");
    user.login = r.getString("login");
    ...
    return user;
};)

// Step 4: Get implementation for SQL interface
UserSql userSql = db.attachSql(UserSql.class);

// Step 5: Use SQL interface to perform queries
User user = userSql.getUserByLogin('login');</pre>

                    Example 2: Transactions
                    <pre class="prettyprint">
// Step 1: Create an interface with transactional methods
public interface UserDbi {
    void registerUser(User user);
}

// Step 2: Implement the interface
public class UserDbiImpl implements UserDbi {
    public void registerUser(User user) {
        User copy = userSql.getUserByLogin(user.login);
        assertNull(copy, "Пользователь уже существует: " + user.login);
        user.id = userSql.insertUser(user);
    }
}

// Step 3: Get proxy-adapter for the interface with transactions support
UserDbi userDbi = db.attachDbi(UserDbi.class, new UserDbiImpl());

// Step 4: Use the adapter
userDbi.registerUser(new User("root"));</pre>
                </div>
            </section>

            <section id="Adapter" class="group">
                <h3>mJDBC adapter</h3>
                <p>
                    To start using mJDBC create an instance of <i>com.github.mjdbc.Db</i> providing <i>javax.sql.DataSource</i> object to the factory method:
                </p>
                <pre class="prettyprint">
static Db newInstance(DataSource ds)</pre>
                <p>
                    <a href="#Transactions">Transactional interfaces</a> allows to execute multiple SQL requests within a single transaction: either all
                    of SQL request inside transaction will succeed or no effect on database state will done at all.
                </p>
                <p>
                    Any Java interface can be made transactional. To register the interface as transactional use the following method:
                </p>
                <pre class="prettyprint">
&lt;T&gt; T attachDbi(T impl, Class&lt;T&gt; dbiInterface)</pre>
                <p>
                    <a href="#Sql">SQL interfaces</a> - is a way to create maintainable set of SQL queries that checked for correctness during the interface registration.
                    SQL queries are written as <i>@Sql</i> annotations to methods and parameters are bound with <i>@Bind</i> and <i>@BindBean</i> classes.
                    When SQL interface is registered in mJDBC it returns a Proxy for the interface with SQL queries checked and implemented.
                </p>
                <pre class="prettyprint">
&lt;T&gt; T attachSql(Class&lt;T&gt; sqlInterface)</pre>
                <p>
                    <a href="#Binders"></a>Set of supported SQL interface parameter types can be extended by custom Java types by creating and registering new <i>DbBinder&lt;T&gt;</i> implementations,
                    which are responsible for Java objects mapping to parameters of <i>java.sql.PreparedStatement</i>
                </p>
                <pre class="prettyprint">
&lt;T&gt; void registerBinder(Class&lt;? extends T&gt; binderClass, DbBinder&lt;T&gt; binder)</pre>
                <p>
                    <a href="#Mappers">Return values</a> for SQL interfaces are instantiated using corresponding <i>DbMapper&lt;T&gt;</i> instances.
                    mJDBC supports by default primitive Java types, JDBC types and Java Lists. Support for custom return types can be added by using
                    implementing and registering new <i>DbMapper&lt;T&gt;</i> instance using the following method:
                </p>
                <pre class="prettyprint">
&lt;T&gt; void registerMapper(Class&lt;T&gt; mapperClass, DbMapper&lt;T&gt; mapper)</pre>
                <p>
                    mJDBC provides <a href="#LowLevelApi">low level API</a> to create and run queries without SQL or transactional interfaces still
                    utilising most of the benefits of mJDBC while having full access and control over JDBC objects.
                </p>
                <p>
                    <i>@Nullable</i> and <i>@NotNull</i> annotations are used throughout all API for strict control over <i>null</i> values.
                    Some API calls that may or may not return <i>null</i> are intentionally duplicated and users of the API are encouraged to follow null safety.
                </p>
                <pre class="prettyprint">
@Nullable
&lt;T&gt; T execute(@NotNull DbOp&lt;T&gt; op)

@NotNull
&lt;T&gt; T executeNN(@NotNull DbOpNN&lt;T&gt; op)

void executeV(@NotNull  DbOpV op)</pre>
                <p>
                    mJDBC automatically collects and provides simple <a href="#Profiling">profiling information</a> about
                    number of calls and total time spent in methods of SQL and transactional interfaces.
                    This information is available via <i>getTimers</i> method:
                </p>
                <pre class="prettyprint">
Map&lt;Method, DbTimer&gt; getTimers()</pre>
            </section>

            <section id="Transactions" class="group">
                <h3>Транзакции</h3>
                mJDBC предоставляет следующий механизм поддержки транзакций:
                <ul class="spec-list">
                    <li>Разработчик описывает и имплементирует Java интерфейс</li>
                    <li>mJDBC предоставляет свою прокси-имплементацию этого интерфейса, при вызове методов которого
                        создаются транзакции и вызывается оригинальная имплементация
                    </li>
                    <li>Разработчик работает с proxy-имплементацией своего интерфейса.</li>
                </ul>
                <p>
                    Каждый метод интерфейса представляет из себя отдельную транзакцию: метод <i>commit</i> для транзакции вызывается при успешном завершении метода.
                    Метод <i>rollback</i> - если имплементация производит исключение.
                </p>
                <p>
                    В случае, если один транзакционный метод вызывает другой транзакционный метод, новой транзакции не создается.
                    Вызванный метод становится частью верхнеуровневой транзакции.
                </p>
                <p>
                    Реализация транзакций mJDBC устроена так, что реальная транзакция, так же как и запрос соединения и <i>java.sql.DataSource</i> происходит не в момент вызова прокси-метода,
                    а при первом реальном исполнении SQL. Таким образом, вызовы которые не производят операций с базой, например, используют кэш или проверяют аргументы и
                    возвращают код ошибки, выполняются значительно быстрее.
                </p>
                <p>
                    Транзакционные интерфейсы ничем не отличаются от обычных Java интерфейсов: mJDBC не требует наследования маркерных интерфейсов или наличия аннотаций.
                    Для получения имплементации транзакционного интерфейса необходимо зарегистрировать его и его имплементацию при помощи вызова:
                </p>
                <pre class="prettyprint">
@NotNull
&lt;T&gt; T attachDbi(@NotNull T impl, @NotNull Class&lt;T&gt; dbiInterface)</pre>
                <p>Сокращение <i>dbi</i> здесь означает: database interface.</p>
                <p> Пример использования транзакционного dbi интерфейса:
                    <i>
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/asset/dbi/SampleDbi.java" target="_blank" class="nw">SampleDbi</a>,
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/asset/dbi/SampleDbiImpl.java" target="_blank" class="nw">SampleDbiImpl</a>,
                        <a href="https://github.com/mjdbc/mjdbc/blob/master/src/test/java/com/github/mjdbc/test/SamplesTest.java" target="_blank" class="nw">SamplesTest</a>.
                    </i>
                </p>
            </section>

            <section id="Sql" class="group">
                <h3>SQL интерфейс</h3>
                <p>
                    SQL интерфейс - это Java интерфейс, где каждый метод является отдельным SQL запросом. mJDBC создает готовую к использованию имплементацию для таких интерфейсов.
                    Разработчик использует созданную mJDBC имплементацию для исполнения операций с базой данных вызывая методы интерфейса.</p>
                <p>
                    Для того, чтобы описать SQL интерфейс нужно:
                </p>
                <ul class="spec-list">
                    <li>Создать обычный Java интерфейс, где каждый метод будет соответствовать одному SQL запросу.</li>
                    <li>Написать для каждого метода реальный SQL запрос на языке используемой базы данных и поместить этот запрос в виде аннотации <i>@Sql</i> к методу.</li>
                    <li>Привязать параметры Java метода к параметрам SQL запроса используя <i>@Bind</i> и <i>@BindBean</i> аннотации.</li>
                    <li>Получить имплементацию описанного интерфейса у mJDBC.</li>
                </ul>
                <p>
                    Пример SQL интерфейса:
                </p>
                <pre class="prettyprint">
public interface UserSql {
    @NotNull
    @GetGeneratedKeys
    @Sql("INSERT INTO users(login, first_name, last_name)
                    VALUES (:login, :firstName, :lastName)")
    UserId insertUser(@BindBean User user);

    @Nullable
    @Sql("SELECT * FROM users WHERE id = :id")
    User getUserById(@Bind("id") UserId id);

    @Nullable
    @Sql("SELECT * FROM users WHERE login = :login")
    User getUserByLogin(@Bind("login") String login);

    @Sql("SELECT COUNT(*) FROM users")
    int countUsers();
}</pre>
                <p>
                    Для того, чтобы получить реализацию этого интерфейса следует вызвать следующий метод mJDBC:
                </p>
                <pre class="prettyprint">
@NotNull
&lt;T&gt; T attachSql(@NotNull Class &lt;T&gt; sqlInterface);
</pre>
                <p>
                    При этом произойдет парсинг и проверка запроса на предмет корректности подстановки параметров и возвращаемых значений.
                </p>
                <p>
                    Подставляемые параметры в SQL запросе именованы и имеют префикс к имени в виде двоеточия: ':'.
                </p>
                <p>
                    Соответствие SQL и Java параметров строится по их именам. Для этого для Java параметров используется аннотация <i>@Bind</i>
                    в которой указывается имя соответствующего SQL параметра. Также, для объектных типов возможно использование аннотации @BindBean:
                    в этом случае в качестве параметров SQL будут подставлены имена и значения полей Java объекта.
                    Поля объекта должны быть публичными, либо иметь публичные <i>get</i>-методы.
                </p>
                <p>
                    Исполнение каждого SQL запроса приведет к созданию и исполнению <i>java.sql.PreparedStatement</i>. При этом, для параметров имеющих базовые
                    Java или JDBC типы вызовется соответствующий метод из PreparedStatement. Для того, чтобы в качестве параметров использовать свои собственные
                    типы данных необходимо зарегистрировать в mJDBC механизм отображения параметров в виде имплементации класса
                    <a href="#Binders"> <i>DbBinder</i></a>, либо унаследовать интерфейс описывающий поддерживаемый mJDBC тип:
                    <a href="https://github.com/mjdbc/mjdbc/blob/master/src/main/java/com/github/mjdbc/type/DbInt.java" target="_blank" class="nw"><i>DbInt</i></a>,
                    <a href="https://github.com/mjdbc/mjdbc/blob/master/src/main/java/com/github/mjdbc/type/DbString.java" target="_blank" class="nw"><i>DbString</i></a> etc.
                </p>
                <p>
                    В случае, если SQL запрос возвращает нестандартный тип данных необходимо зарегистрировать его отображение из <i>java.sql.ResultSet</i> при помощи
                    реализации класса <a href="#Mappers"><i>DbMapper</i></a>. Списки (<i>java.util.List</i>) и базовые Java и JDBC типы поддерживаются
                    mJDBC автоматически.
                </p>
                <p>
                    Для возврата авто-генерируемого значения, можно использовать аннотацию <i>@GetGeneratedKeys</i>.
                    Использование <i>@GetGeneratedKeys</i> в коде не обязательно для запросов начинающихся с префикса "INSERT ":
                    для них возврат генерируемого значения происходит по умолчанию.
                </p>
                <p>
                    В случае, если Java параметр является коллекцией, итератором или массивом, вместо одного запроса будет выполнена серия <a href="#Batch">batch-запросов</a>.
                </p>

            </section>

            <section id="Binders" class="group">
                <h3>SQL параметры</h3>
                <p>
                    Для работы с параметрами <a href="#Sql">SQL интерфейса</a> используются интерфейс <i>DbBinder</i> и аннотации <i>@Bind</i> и <i>@BindBean</i>.
                    Интерфейс DbBinder описывает как параметр указанного Java типа должен быть сериализован в качестве параметра <i>java.sql.PreparedStatements</i>:
                </p>
                <pre class="prettyprint">
public interface DbBinder&lt;T&gt; {
    void bind(PreparedStatement statement, int idx, T value)
}</pre>
                <p>При исполнении SQL-запроса mJDBC автоматически подбирает подходящую реализацию <i>DbBinder</i> из набора всех зарегистрированных.
                    При этом, приоритет поиска <i>DbBinder</i> следующий:</p>
                <ul class="spec-list">
                    <li>Точное совпадение с типом класса параметра.</li>
                    <li>Точное совпадение с типом родительского класса параметра.</li>
                    <li>Совпадение с одним из имплементированных интерфейсов.</li>
                </ul>
                <p>
                    При наличии более одного подходящего интерфейса производится исключение: <i>java.lang.IllegalArgumentException.</i>
                    Процесс подбора <i>DbBinder</i> происходит на момент регистрации SQL интерфейса в mJDBC.
                </p>
                <p>Для регистрации новых реализаций <i>DbBinder</i> используется метод</p>
                <pre class="prettyprint">
&lt;T&gt; void registerBinder(Class&lt;? extends T&gt; binderClass, DbBinder&lt;T&gt; binder)</pre>
                <p>
                    Аннотация <i>@Bind</i> используется для указания точного имени параметра <i>java.sql.PreparedStatement</i>.
                </p>
                <p>
                    Аннотация <i>@BindBean</i> говорит о том, что имена параметров должны совпадать с именами публичных полей или <i>get</i>-методов объекта.
                    В текущей версии mJDBC параметр описанный при помощи <i>@BindBean</i> должен быть единственным параметром интерфейса.
                </p>
                <p>
                    В случае, если SQL запрос содержит больше именованных параметров, чем доступно из данных <i>@Bind</i> и <i>@BindBean</i> аннотаций,
                    производится исключение. Лишние параметры со стороны Java игнорируются. Имена параметров могут содержать только символы Java идентификаторов.
                </p>
                <p>Проверка на полноту и корректность SQL параметров происходит в момент регистрации SQL-интерфейса.</p>

            </section>

            <section id="Mappers" class="group">
                <h3>SQL результаты</h3>
                <p>
                    mJDBC необходимо знать каким образом преобразовывать возвращаемые SQL интерфейсом данные в Java объекты.
                    По умолчанию mJDBC поддерживает все примитивные Java типы и их объектные аналоги, типы <i>java.sql.Date</i>, <i>java.sql.Timestamp</i>, <i>java.util.Date</i>,
                    <i>java.math.BigDecimal</i> и интерфейс списков <i>java.util.List</i>. Для списков в качестве реализации используется <i>java.util.ArrayList</i>.
                </p>
                <p>
                    Для того, чтобы расширить диапазон поддерживаемых типов необходимо зарегистрировать реализацию интерфейса <i>DbMapper</i>, которая из текущей позиции
                    <i>ResultSet</i> создаст и заполнит нужными значениями экземпляр возвращаемого объекта:
                </p>
                    <pre class="prettyprint">
public interface DbMapper&lt;T&gt; {
    T map(@NotNull java.sql.ResultSet r) throws SQLException;
}</pre>

                <p>Например: </p>
                <pre class="prettyprint">
DbMapper&lt;User&gt; mapper = (r) -&gt; {
    User user = new User();
    user.id = new UserId(r.getInt("id"));
    user.login = r.getString("login");
    return user;
}
db.registerMapper(User.class, mapper);
</pre>
                <p>
                    Существует несколько техник, которые позволяют mJDBC автоматически находить необходимые реализации <i>DbMapper</i> для возвращаемых методами SQL интерфесов типов,
                    делая их ручную регистрацию опциональной. Для этого, для возвращаемого типа <i>T</i> должно быть выполнено следующее условие:
                </p>
                <ul class="spec-list">
                    <li>Присутствует публичное статическое финальное поле с аннотацией <i>@Mapper</i> и типом <i>DbMapper&lt;T&gt;</i></li>
                </ul>
                <p>
                    Автоматический поиск нужного экземпляра происходит при условии, что для типа <i>T</i> нет экземпляра <i>DbMapper&lt;T&gt;</i> зарегистрированного вручную.
                </p>
                <p>
                    Поиск происходит на момент регистрации SQL интерфейса.
                    В случае, если в результате поиска найдено 2 или более кандидата на роль <i>DbMapper</i>, выбрасывается исключение и регистрации SQL-интерфейса не происходит.</p>
                <p>
                    Повторные прямые вызовы метода <i>registerMapper</i> допускаются и приводят к регистрации нового обработчика <i>DbMapper</i> для указанного типа.
                </p>
            </section>

            <section id="Batch" class="group">
                <h3>Batch операции</h3>
                <p>
                    Batch операции используются для оптимизированного исполнения серии однотипных операций над базой данных. Например:
                </p>
                <pre class="prettyprint">
@Sql("UPDATE users SET score = :score WHERE id = :id")
void updateScore(@Bind("id") int[] ids, @Bind("score") int score);

@Sql(&quot;UPDATE users SET score = :score WHERE id = :id&quot;)
void updateScore(@BindBean List&lt;User&gt; users);

@Sql(&quot;INSERT INTO users(login, score) VALUES (:login, :score)&quot;)
void insertUsers(@BindBean List&lt;User&gt; users);</pre>
                <p>
                    При этом mJDBC использует один экземпляр <i>java.sql.PreparedStatement</i> с помощью которого исполняются стандартные JDBC
                    <i>addBatch/executeBatch</i> операции.
                </p>
                <p>Количество вызовов метода <i>addBatch</i> перед каждым <i>executeBatch</i> задается параметром <i>batchChunkSize</i> аннотации <i>@Sql</i>.
                    Значение по умолчанию для этого параметра: <i>Integer.MAX_VALUE</i>.</p>
                <pre class="prettyprint">
@Sql(value = &quot;UPDATE users SET score = :score WHERE id = :id&quot;,
     batchChunkSize = 100)
void updateScore(@BindBean List&lt;User&gt; users);

                </pre>
                <p>
                    Batch операции поддерживаются для параметров SQL-интерфейса описанных с использованием аннотаций <i>@Bind</i> и <i>@BindBean</i>.
                    При этом допускается присутствие только одного batch-параметра в запросе.
                </p>
                <p>
                    Batch-параметр определяется по принадлежности к одному из следующих типов: Java массив, <i>java.util.Iterable</i> или <i>java.util.Iterator</i>.
                </p>
            </section>

            <section id="Profiling" class="group">
                <h3>Профилировка</h3>
                mJDBC отслеживает суммарное время исполнения и количество вызовов для всех зарегистрированных SQL-запросов и транзакционных методов.
                Для доступа к этой информации используется метод
                <pre class="prettyprint">
@NotNull
Map&lt;Method, DbTimer&gt; getTimers();</pre>
                где <i>DbTimer</i> является следующей структурой:
                <pre class="prettyprint">
public final class DbTimer {
    @NotNull
    private final Method method;

    protected volatile long invocationCount;

    protected volatile long totalTimeInNanos;</pre>
            </section>

            <section id="LowLevelApi" class="group">
                <h3>Низкоуровневый интерфейс</h3>
                <div class="subgroup">
                    <h4 id="DbOp">Транзакции</h4>
                    <p>
                        mJDBC позволяет работать с транзакциями и SQL запросами без использования транзакционных и SQL интерфейсов,
                        что может быть удобно для небольших приложений, либо если текущий
                        функционал интерфейсов mJDBC недостаточен.
                    </p>
                    <p>
                        Для того, чтобы выполнить транзакционную SQL операцию без использования SQL интерфейса можно использовать одни из следующих методов mJDBC:
                    </p>
                <pre class="prettyprint">
@Nullable
&lt;T&gt; T execute(@NotNull DbOp&lt;T&gt; op);

@NotNull
&lt;T&gt; T executeNN(@NotNull DbOpNN&lt;T&gt; op);

void executeV(@NotNull DbOpV op);</pre>
                    <p>При вызове любого из этих методов имплементация интерфейса <i>DbOp</i> будет исполнена как отдельная транзакция,
                        также как исполняется отдельный метод транзакционного интерфейса.</p>
                <pre class="prettyprint">
/**
 * Database operation with @Nullable result.
 */
public interface DbOp&lt;T&gt; {
    @Nullable
    T run(@NotNull DbConnection c) throws Exception;
}

/**
 * Database operation with no result.
 */
public interface DbOpV {
    void run(@NotNull DbConnection c) throws Exception;
}

/**
 * Database operation with @NotNull result.
 */
public interface DbOpNN&lt;T&gt; {
    @NotNull
    T run(@NotNull DbConnection c) throws Exception;
}</pre>
                    <p>Присутствие трех различных интерфейсов отличающихся лишь типом возвращаемого результата сделано для
                        удобства использования и возможности использования статических анализаторов кода.</p>
                    <p>Параметр <i>DbConnection</i> предоставляет прямой доступ к <i>java.sql.Connection</i>
                        и используется mJDBC для использования совместно с классом <i>DbPreparedStatement</i> описанным ниже.</p>
                    <p>В случае, если верхнеуровневый <i>DbOp.run</i> метод завершается без выбрасывания исключения, у текущей транзакции вызывается метод <i>commit</i>.
                        Иначе вызывается метод <i>rollback</i>. Вложенные вызовы <i>execute(DbOp)</i> не приводят к созданию новых транзакций и встраиваются в
                        транзакционный контекст вызывающего метода.</p>
                </div>
                <div class="subgroup">
                    <h4 id="DbStatement">SQL запросы</h4>
                    <p>
                        Для создания SQL запросов без использования SQL интерфейса mJDBC предоставляет класс <i>DbPreparedStatement</i>. Этот класс является оболочкой и
                        предоставляет полный доступ к <i>java.sql.PreparedStatement</i>, а также предоставляет следующий дополнительный функционал:
                    </p>
                    <ul class="spec-list">
                        <li>Работа с именованными параметрами.</li>
                        <li>Проверка корректности привязки параметров на момент создания.</li>
                        <li>Отображения результатов в Java объекты при помощи <i>DbMapper</i>.</li>
                        <li>Автоматическое освобождение ресурсов при завершении транзакции/соединения.</li>
                    </ul>
                    <p>
                        Примеры использования <i>DbPreparedStatement</i> совместно с <i>DbOp</i>:
                    </p>
                    <pre class="prettyprint">
List&lt;User&gt; users = db.execute(c -&gt;
    new DbPreparedStatement&lt;&gt;(c, &quot;SELECT * FROM users&quot;, User.class)
        .queryList());</pre>

            <pre class="prettyprint">
User user = db.execute(c -&gt;
    new DbPreparedStatement&lt;&gt;(c, &quot;SELECT * FROM users WHERE login = :login&quot;, User.class).set("login", "admin").query());</pre>
                </div>
                <p>Все операции с <i>DbPreparedStatement</i> выполненные внутри <i>DbOp</i> метода являются частью одной транзакции.
                    Все связанные с ними ресурсы отслеживаются mJDBC и автоматически высвобождаются по завершении транзакции.</p>

            </section>
            <section id="Recommendations" class="group">
                <h3>Рекомендации</h3>
                <ul class="spec-list">
                    <li>Используйте примеры с открытым исходным кодом:
                        <a href="https://github.com/mjdbc/mjdbc/tree/master/src/test/java/com/github/mjdbc/test" target="_blank">тесты</a>,
                        <a href="https://github.com/mfursov/wicket7template/tree/master/src/main/java/com/github/mfursov/w7/db" target="_blank">другие проекты</a> на GitHub.
                    </li>
                    <li>Используйте пулы для соединения с базой данных. Пример: <a href="https://brettwooldridge.github.io/HikariCP/" target="_blank">HikariCP</a></li>
                </ul>
            </section>
            <!--Nav Bar -->
            <nav class="col-xs-3 bs-docs-sidebar">
                <ul id="sidebar" class="nav nav-stacked fixed">
                    <li><a href="#About">About</a></li>
                    <li><a href="#Install">Installation</a></li>
                    <li><a href="#Examples">Examples</a></li>
                    <li><a href="#Adapter">mJDBC adapter</a></li>
                    <li><a href="#Transactions">Transactions</a></li>
                    <li><a href="#Sql">SQL interfaces</a></li>
                    <li><a href="#Binders">SQL parameters</a></li>
                    <li><a href="#Mappers">SQL results</a></li>
                    <li><a href="#Batch">Batch operations</a></li>
                    <li><a href="#Profiling">Profiling</a></li>
                    <li><a href="#LowLevelApi">Low level API</a>
                        <ul class="nav nav-stacked">
                            <li><a href="#DbOp">Transactions</a></li>
                            <li><a href="#DbStatement">SQL queries</a></li>
                        </ul>
                    </li>
                    <li><a href="#Recommendations">Recommendations</a></li>
                </ul>
            </nav>
        </div>
    </div>
    <script>
        $('body').scrollspy({
            target: '.bs-docs-sidebar',
            offset: 40
        });
    </script>
</div>
</body>
</html>
